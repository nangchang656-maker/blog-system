章模块系统设计

  一、数据库设计

  1.1 核心表结构

  article 表（文章主表）

  CREATE TABLE `article` (
    `id` bigint PRIMARY KEY AUTO_INCREMENT,
    `user_id` bigint NOT NULL COMMENT '作者ID',
    `title` varchar(200) NOT NULL COMMENT '标题',
    `content` text NOT NULL COMMENT 'Markdown内容',
    `summary` varchar(500) COMMENT '摘要',
    `cover_image` varchar(500) COMMENT '封面图URL',
    `category_id` bigint COMMENT '分类ID',
    `status` tinyint DEFAULT 0 COMMENT '状态:0-草稿,1-已发布',
    `view_count` int DEFAULT 0 COMMENT '浏览量',
    `like_count` int DEFAULT 0 COMMENT '点赞数',
    `comment_count` int DEFAULT 0 COMMENT '评论数',
    `collect_count` int DEFAULT 0 COMMENT '收藏数',
    `is_top` tinyint DEFAULT 0 COMMENT '是否置顶',
    `create_time` datetime DEFAULT CURRENT_TIMESTAMP,
    `update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    `deleted` tinyint DEFAULT 0 COMMENT '逻辑删除',
    INDEX idx_user_id (user_id),
    INDEX idx_category_id (category_id),
    INDEX idx_status (status),
    INDEX idx_create_time (create_time)
  ) COMMENT='文章表';

  article_tag 表（文章标签关联）

  CREATE TABLE `article_tag` (
    `id` bigint PRIMARY KEY AUTO_INCREMENT,
    `article_id` bigint NOT NULL COMMENT '文章ID',
    `tag_id` bigint NOT NULL COMMENT '标签ID',
    `create_time` datetime DEFAULT CURRENT_TIMESTAMP,
    UNIQUE KEY uk_article_tag (article_id, tag_id),
    INDEX idx_tag_id (tag_id)
  ) COMMENT='文章标签关联表';

  1.2 索引设计策略

  | 索引名称            | 字段                 | 类型   | 用途       |
  |-----------------|--------------------|------|----------|
  | idx_user_id     | user_id            | 普通索引 | 查询用户文章列表 |
  | idx_category_id | category_id        | 普通索引 | 按分类筛选    |
  | idx_status      | status             | 普通索引 | 区分草稿/发布  |
  | idx_create_time | create_time        | 普通索引 | 时间排序     |
  | uk_article_tag  | article_id, tag_id | 唯一索引 | 防止重复关联   |

  ---
  二、接口设计

  2.1 RESTful API 规范

  文章管理接口

  | 方法     | 路径                   | 功能   | 认证  | 说明        |
  |--------|----------------------|------|-----|-----------|
  | POST   | /api/article/publish | 发布文章 | ✅   | 支持草稿/发布状态 |
  | PUT    | /api/article/{id}    | 更新文章 | ✅   | 权限验证：仅作者  |
  | DELETE | /api/article/{id}    | 删除文章 | ✅   | 逻辑删除      |
  | GET    | /api/article/list    | 文章列表 | ❌   | 分页+筛选+排序  |
  | GET    | /api/article/{id}    | 文章详情 | ❌   | 自动+1浏览量   |
  | GET    | /api/article/my      | 我的文章 | ✅   | 包含草稿      |

  互动接口

  | 方法   | 路径                          | 功能   | 认证  |
  |------|-----------------------------|------|-----|
  | POST | /api/article/{id}/like      | 点赞   | ✅   |
  | POST | /api/article/{id}/unlike    | 取消点赞 | ✅   |
  | POST | /api/article/{id}/collect   | 收藏   | ✅   |
  | POST | /api/article/{id}/uncollect | 取消收藏 | ✅   |

  2.2 请求/响应示例

  发布文章请求

  POST /api/article/publish
  {
    "title": "Spring Boot 最佳实践",
    "content": "# 一级标题\n\n正文内容...",
    "summary": "本文介绍Spring Boot开发中的...",
    "coverImage": "https://cdn.example.com/cover.jpg",
    "categoryId": 1,              // 优先使用ID
    "categoryName": "后端技术",   // ID为空时用名称创建
    "tagIds": [1, 2, 3],          // 优先使用ID列表
    "tagNames": ["Java", "框架"], // ID列表为空时用名称创建
    "status": 1                   // 0-草稿, 1-发布
  }

  文章列表查询

  GET /api/article/list?page=1&size=10&categoryId=1&tagId=2&keyword=Spring&orderBy=
  create_time&orderType=desc

  // 响应
  {
    "code": 200,
    "message": "success",
    "data": {
      "records": [
        {
          "id": 1,
          "title": "文章标题",
          "summary": "文章摘要...",
          "coverImage": "封面URL",
          "categoryId": 1,
          "categoryName": "后端技术",
          "tags": [
            { "id": 1, "name": "Java" },
            { "id": 2, "name": "Spring" }
          ],
          "authorId": 100,
          "authorName": "张三",
          "authorAvatar": "头像URL",
          "viewCount": 1234,
          "likeCount": 56,
          "commentCount": 12,
          "createTime": "2025-11-04T10:30:00",
          "updateTime": "2025-11-04T15:20:00"
        }
      ],
      "total": 100,
      "current": 1,
      "size": 10
    }
  }

  文章详情响应

  GET /api/article/123

  {
    "code": 200,
    "data": {
      "id": 123,
      "title": "文章标题",
      "content": "# Markdown内容\n\n...",  // 完整内容
      "summary": "摘要",
      "coverImage": "封面URL",
      "categoryId": 1,
      "categoryName": "后端技术",
      "tags": [...],
      "authorId": 100,
      "authorName": "张三",
      "authorAvatar": "头像URL",
      "viewCount": 1235,           // 已自动+1
      "likeCount": 56,
      "commentCount": 12,
      "isLiked": true,              // 当前用户是否点赞
      "isCollected": false,         // 当前用户是否收藏
      "createTime": "2025-11-04T10:30:00",
      "updateTime": "2025-11-04T15:20:00"
    }
  }

  ---
  三、业务逻辑设计

  3.1 文章发布流程

  graph TD
      A[前端提交] --> B{分类处理}
      B -->|有categoryId| C[验证分类存在]
      B -->|无categoryId| D[用categoryName创建/获取]
      C --> E[创建文章记录]
      D --> E
      E --> F{标签处理}
      F -->|有tagIds| G[验证标签存在]
      F -->|无tagIds| H[用tagNames创建/获取]
      G --> I[批量插入article_tag]
      H --> I
      I --> J[返回文章ID]

  关键点：
  1. 分类/标签自动创建：前端可传ID或名称，后端自动处理
  2. 事务控制：文章创建+标签关联在同一事务
  3. 权限验证：通过 SecurityContextUtil.getCurrentUserId() 获取当前用户

  3.2 文章列表查询优化

  问题：N+1查询

  ❌ 低效方式：循环查询每篇文章的作者、分类、标签
  for (Article article : articles) {
      User author = userMapper.selectById(article.getUserId());      // N次查询
      Category category = categoryMapper.selectById(article.getCategoryId()); // 
  N次查询
      List<Tag> tags = tagMapper.selectByArticleId(article.getId()); // N次查询
  }

  ✅ 批量查询优化（已实现）：
  // 1. 批量查询作者（1次SQL）
  List<Long> userIds = articles.stream().map(Article::getUserId).distinct().collect
  (Collectors.toList());
  List<User> users = userMapper.selectBatchIds(userIds);
  Map<Long, User> userMap = users.stream().collect(Collectors.toMap(User::getId, u
  -> u));

  // 2. 批量查询分类（1次SQL）
  List<Long> categoryIds = ...;
  Map<Long, Category> categoryMap = ...;

  // 3. 批量查询标签（2次SQL：article_tag关联 + tag信息）
  Map<Long, List<Tag>> articleTagsMap = getArticleTagsMap(articleIds);

  性能对比：
  - 10篇文章，低效方式：31次SQL（1 + 10×3）
  - 10篇文章，优化方式：4次SQL（1 + 1 + 1 + 1）

  3.3 浏览量统计方案

  当前实现（同步直接更新）

  articleMapper.incrementViewCount(articleId);  // 每次查看 +1

  优化方案（待实现）

  | 方案           | 实现方式                   | 优点         | 缺点         |
  |--------------|------------------------|------------|------------|
  | Redis计数器     | ZSet存储文章浏览量，定时同步到MySQL | 高性能、减少DB压力 |
  数据延迟、需定时任务 |
  | RocketMQ异步   | 发送浏览事件到MQ，消费者批量更新      | 解耦、削峰填谷    |
  有延迟、需MQ环境  |
  | Redis + MQ组合 | Redis实时计数，MQ异步持久化      | 最佳性能       | 架构复杂
       |

  推荐实现（符合项目技术栈）：
  // ArticleServiceImpl.java:261
  // TODO: 使用RocketMQ异步处理
  rocketMQProducer.sendViewEvent(articleId, userId);  // 发送浏览事件

  // Redis实时计数
  String key = "article:view:" + articleId;
  redisUtil.increment(key, 1);

  // 定时任务（每5分钟）
  @Scheduled(cron = "0 */5 * * * ?")
  public void syncViewCount() {
      // 从Redis批量同步到MySQL
  }

  3.4 标签筛选逻辑

  需求：前端选择标签时，只显示包含该标签的文章

  实现方式：
  // ArticleServiceImpl.java:405-412
  .filter(article -> {
      if (filterTagId != null) {
          List<Tag> tags = articleTagsMap.get(article.getId());
          return tags != null && tags.stream().anyMatch(tag ->
  tag.getId().equals(filterTagId));
      }
      return true;
  })

  性能考虑：
  - ✅ 已批量加载所有标签，内存过滤不影响性能
  - ⚠️ 如果文章量大（>1000），建议改为SQL筛选
  WHERE id IN (SELECT article_id FROM article_tag WHERE tag_id = ?)

  ---
  四、安全设计

  4.1 权限控制

  | 接口   | 认证要求 | 权限验证                               |
  |------|------|------------------------------------|
  | 发布文章 | 必须登录 | -                                  |
  | 更新文章 | 必须登录 | article.getUserId().equals(userId) |
  | 删除文章 | 必须登录 | article.getUserId().equals(userId) |
  | 查看列表 | 免登录  | @NoLogin 注解                        |
  | 查看详情 | 免登录  | 未登录时 isLiked/isCollected 为 false   |

  实现机制：
  // 1. @NoLogin 注解：跳过JWT验证
  @NoLogin
  @GetMapping("/list")
  public R getArticleList(ArticleQueryDTO queryDTO) { ... }

  // 2. 详情接口兼容未登录：
  try {
      userId = SecurityContextUtil.getCurrentUserId();
  } catch (Exception e) {
      // 未登录，忽略异常，userId = null
  }

  4.2 数据校验

  后端校验（已实现）

  @Valid ArticlePublishDTO dto  // 使用 Hibernate Validator

  // DTO中的校验注解
  @NotBlank(message = "标题不能为空")
  @Size(max = 200, message = "标题长度不能超过200字符")
  private String title;

  @NotBlank(message = "内容不能为空")
  private String content;

  业务校验

  // 1. 分类存在性
  if (categoryId != null && categoryMapper.selectById(categoryId) == null) {
      throw new CommonException("分类不存在");
  }

  // 2. 标签存在性
  for (Long tagId : tagIds) {
      if (tagMapper.selectById(tagId) == null) {
          throw new CommonException("标签ID[" + tagId + "]不存在");
      }
  }

  // 3. 权限验证
  if (!article.getUserId().equals(userId)) {
      throw new CommonException("无权限编辑此文章");
  }

  4.3 XSS防护

  风险点：文章内容为Markdown，可能包含恶意脚本

  防护措施：
  1. 前端渲染时过滤（推荐）
  import DOMPurify from 'dompurify'
  const cleanHtml = DOMPurify.sanitize(markdownToHtml(article.content))
  2. 后端存储时过滤（可选）
  String safeContent = HtmlUtils.htmlEscape(dto.getContent());
  3. CSP策略（HTTP Header）
  Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline'

  ---
  五、前端架构设计

  5.1 页面路由

  // router/index.ts
  {
    path: '/article',
    children: [
      { path: '', name: 'article-list', component: ArticleListView },
      { path: ':id', name: 'article-detail', component: ArticleDetailView },
      { path: 'create', name: 'article-create', component: ArticleEditorView },
      { path: 'edit/:id', name: 'article-edit', component: ArticleEditorView },
      { path: 'my', name: 'my-articles', component: MyArticlesView }
    ]
  }

  5.2 状态管理（建议）

  当前问题：每个页面独立管理状态，可能导致重复请求

  优化方案：使用 Pinia 全局状态
  // stores/article.ts
  import { defineStore } from 'pinia'

  export const useArticleStore = defineStore('article', {
    state: () => ({
      categories: [] as Category[],      // 缓存分类列表
      hotTags: [] as Tag[],              // 缓存热门标签
      currentArticle: null as ArticleDetail | null
    }),
    actions: {
      async loadCategories() {
        if (this.categories.length === 0) {  // 避免重复请求
          const res = await getCategoryList()
          this.categories = res.data
        }
      }
    }
  })

  5.3 组件设计

  ArticleListView (文章列表页)
  ├── SearchCard (搜索筛选组件)
  │   ├── CategorySelect (分类选择器)
  │   ├── TagCloud (标签云)
  │   └── SortSelector (排序选择器)
  ├── ArticleCard (文章卡片) x N
  │   ├── CoverImage (封面图)
  │   ├── ArticleInfo (文章信息)
  │   └── ArticleMeta (元信息：作者、浏览量等)
  └── Pagination (分页组件)

  复用性设计：
  - ArticleCard 组件可在多个页面复用（首页、搜索结果、我的文章）
  - TagCloud 组件可在侧边栏、筛选栏复用

  ---
  六、性能优化策略

  6.1 数据库层优化

  | 优化点  | 实现方式                              | 效果         |
  |------|-----------------------------------|------------|
  | 批量查询 | selectBatchIds()                  | 减少SQL次数    |
  | 索引覆盖 | idx_status + idx_create_time 联合索引 | 避免回表       |
  | 逻辑删除 | deleted 字段 + 索引条件                 | 数据可恢复      |
  | 分页优化 | 避免 count(*) 深分页                   | 前端显示"加载更多" |

  6.2 缓存策略（待实现）

  // 1. 文章详情缓存（30分钟）
  String cacheKey = RedisKeyEnum.ARTICLE_DETAIL.getKey(articleId);
  ArticleDetailVO cached = redisUtil.get(cacheKey);
  if (cached != null) return cached;

  // 2. 热门文章榜单（ZSet）
  redisUtil.zIncrementScore("article:hot", articleId, 1);  // 浏览+1

  // 3. 分类/标签列表缓存（1天）
  // 这些数据变化频率低，适合长期缓存

  6.3 前端优化

  <!-- 图片懒加载 -->
  <el-image :src="article.coverImage" lazy />

  <!-- 虚拟滚动（文章列表>100时） -->
  <virtual-scroller :items="articles" />

  <!-- 路由懒加载 -->
  const ArticleDetailView = () => import('@/views/article/ArticleDetailView.vue')

  ---
  七、扩展性设计

  7.1 ElasticSearch集成预留

  当前实现：MySQL LIKE 查询
  WHERE title LIKE '%keyword%' OR summary LIKE '%keyword%'

  ES集成方案：
  1. 数据同步：监听 article 表变化 → 同步到ES
    - Canal监听MySQL binlog
    - 或在 ArticleService 增删改时手动同步
  2. 搜索接口改造：
  if (StringUtils.hasText(keyword)) {
      // 调用 ElasticsearchTemplate 搜索
      return elasticsearchService.searchArticles(keyword, page);
  }
  3. 索引结构：
  {
    "mappings": {
      "properties": {
        "id": { "type": "long" },
        "title": { "type": "text", "analyzer": "ik_max_word" },
        "content": { "type": "text", "analyzer": "ik_smart" },
        "summary": { "type": "text" },
        "tags": { "type": "keyword" },
        "createTime": { "type": "date" }
      }
    }
  }

  7.2 AI功能集成点

  前端已定义接口（article.ts:229-258）：
  generateSummary(content: string)   // AI生成摘要
  polishContent(content: string)     // AI润色内容
  generateOutline(topic: string)     // AI生成大纲

  后端实现方案：
  @RestController
  @RequestMapping("/api/ai")
  public class AIController {

      @Autowired
      private ZhipuAIService zhipuAIService;

      @PostMapping("/summary")
      public R generateSummary(@RequestBody AIRequestDTO dto) {
          String summary = zhipuAIService.generateSummary(dto.getContent());
          return R.success(summary);
      }
  }

  集成位置：文章编辑器的工具栏按钮
  <el-button @click="handleAISummary">AI生成摘要</el-button>

  ---
  八、测试要点

  8.1 功能测试清单

  - 发布文章
    - 草稿状态发布
    - 正式发布
    - 分类名称自动创建
    - 标签名称自动创建
    - 封面图上传
  - 编辑文章
    - 只能编辑自己的文章
    - 更新标签（新增/删除）
    - 草稿 → 发布状态切换
  - 删除文章
    - 逻辑删除验证
    - 关联标签清理
  - 文章列表
    - 分页功能
    - 分类筛选
    - 标签筛选
    - 关键词搜索
    - 排序（时间/浏览/点赞）
  - 文章详情
    - 浏览量自动+1
    - 未登录时正常显示
    - 已登录时显示点赞/收藏状态
  - 互动功能
    - 点赞/取消点赞
    - 收藏/取消收藏
    - 点赞数/收藏数同步更新

  8.2 性能测试

  # 1. 并发查询文章列表（100并发）
  ab -n 1000 -c 100 http://localhost:8080/api/article/list?page=1&size=10

  # 2. 并发查看文章详情（模拟浏览量压测）
  ab -n 5000 -c 200 http://localhost:8080/api/article/123

  # 3. SQL慢查询监控
  SET GLOBAL slow_query_log = 'ON';
  SET GLOBAL long_query_time = 0.5;  -- 超过0.5秒记录

  8.3 Mapper XML 检查

● Read(blog-application/src/main/resources/mapper/ArticleMapper.xml)
  ⎿  Read 48 lines

● ✅ Mapper XML 已完整实现：6个统计更新方法（浏览、点赞、评论、收藏的增减）

  需要检查其他 Mapper 接口文件：

● Bash(find
      /home/lzx/projects2/MyBlog/blog-application/src/main/java/cn/lzx/blog/mapper
      -name "*.java" -exec basename {} \;)
  ⎿  TagMapper.java               
     ArticleMapper.java
     UserMapper.java
     … +4 lines (ctrl+o to expand)

● Read(blog-application/src/main/java/cn/lzx/blog/mapper/ArticleMapper.java)
  ⎿  Read 65 lines

● Read(blog-application/src/main/java/cn/lzx/blog/mapper/TagMapper.java)
  ⎿  Read 45 lines

● 补充：Mapper接口设计

  ArticleMapper

  @Mapper
  public interface ArticleMapper extends BaseMapper<Article> {
      // ✅ 6个自定义方法（已实现XML映射）
      int incrementViewCount(@Param("id") Long id);
      int incrementLikeCount(@Param("id") Long id);
      int decrementLikeCount(@Param("id") Long id);
      int incrementCommentCount(@Param("id") Long id);
      int incrementCollectCount(@Param("id") Long id);
      int decrementCollectCount(@Param("id") Long id);

      // 继承 BaseMapper 的标准CRUD：
      // - insert / deleteById / updateById
      // - selectById / selectBatchIds / selectList / selectPage
  }

  TagMapper（自定义查询）

  @Mapper
  public interface TagMapper extends BaseMapper<Tag> {

      // ✅ 根据文章ID查询标签（JOIN查询）
      @Select("SELECT t.* FROM tag t " +
              "INNER JOIN article_tag at ON t.id = at.tag_id " +
              "WHERE at.article_id = #{articleId}")
      List<Tag> selectByArticleId(@Param("articleId") Long articleId);

      // ✅ 热门标签（按关联文章数排序）
      @Select("SELECT t.id, t.name, COUNT(at.article_id) as article_count " +
              "FROM tag t LEFT JOIN article_tag at ON t.id = at.tag_id " +
              "GROUP BY t.id, t.name ORDER BY article_count DESC LIMIT #{limit}")
      List<Tag> selectHotTags(@Param("limit") Integer limit);
  }

  ---
  九、部署建议

  9.1 数据库初始化脚本

  -- 1. 创建数据库
  CREATE DATABASE blog_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

  -- 2. 初始化测试数据
  INSERT INTO category (name, description) VALUES
  ('后端技术', 'Java、Spring、数据库等'),
  ('前端开发', 'Vue、React、JavaScript等'),
  ('架构设计', '系统架构、微服务、分布式等');

  INSERT INTO tag (name) VALUES
  ('Java'), ('Spring Boot'), ('Vue'), ('MySQL'), ('Redis');

  -- 3. 创建索引（生产环境）
  ALTER TABLE article ADD INDEX idx_status_create (status, create_time);
  ALTER TABLE article ADD INDEX idx_category_status (category_id, status);

  9.2 配置文件环境隔离

  # application-dev.yml（开发环境）
  spring:
    datasource:
      url: jdbc:mysql://localhost:3306/blog_db
    data:
      redis:
        host: localhost

  # application-prod.yml（生产环境）
  spring:
    datasource:
      url: jdbc:mysql://prod-db:3306/blog_db
      hikari:
        maximum-pool-size: 20
    data:
      redis:
        host: redis-cluster

  mybatis-plus:
    configuration:
      log-impl: org.apache.ibatis.logging.nolog.NoLoggingImpl  # 关闭SQL日志

  9.3 监控指标

  // 自定义监控指标（Prometheus + Grafana）
  @Component
  public class ArticleMetrics {

      private final Counter articlePublishCounter = Counter.build()
          .name("article_publish_total")
          .help("文章发布总数").register();

      private final Histogram articleQueryDuration = Histogram.build()
          .name("article_query_duration_seconds")
          .help("文章查询耗时").register();
  }

  ---
  十、总结

  当前架构优势

  1. ✅ 代码规范：Controller-Service-Mapper分层清晰
  2. ✅ 性能优化：批量查询避免N+1问题
  3. ✅ 权限控制：细粒度权限验证（作者才能编辑）
  4. ✅ 扩展性强：预留ES、Redis、MQ集成点
  5. ✅ 前后端分离：RESTful API + TypeScript类型安全

  待完善项

  1. ⚠️ 缓存机制：文章详情、分类标签列表缓存
  2. ⚠️ 异步处理：浏览量统计改为MQ异步
  3. ⚠️ 全文搜索：集成ElasticSearch
  4. ⚠️ 图片上传：集成MinIO/OSS
  5. ⚠️ 单元测试：Service层业务逻辑测试覆盖

  面试亮点话术

  "文章模块采用批量查询优化避免N+1问题，将10篇文章的查询从31次SQL降到4次。支持分类/
  标签智能创建，前端传ID或名称都能自动处理。权限控制采用细粒度验证，只有作者才能编
  辑删除。预留了ES全文搜索和Redis缓存接口，后续可快速集成。"