# 互动模块优化说明

## 优化背景

### 原问题
当使用逻辑删除（`@TableLogic`）时，点赞和收藏功能存在以下问题：
1. 用户取消点赞后再次点赞会失败（唯一索引冲突）
2. 数据库中会累积大量逻辑删除的记录
3. 主键ID不断增长，浪费存储空间

### 解决方案演进

#### ❌ 方案1：添加 deleted 字段到唯一索引
```sql
-- 修改唯一索引包含 deleted 字段
UNIQUE INDEX `uk_user_target_deleted`(`user_id`, `target_id`, `type`, `deleted`)
```
**问题：** 这样可以解决唯一键冲突，但会导致数据库中存在多条相同用户对相同文章的点赞记录（只是deleted值不同），数据不够整洁。

#### ❌ 方案2：物理删除
```java
// 取消点赞时直接物理删除记录
@Delete("DELETE FROM like_record WHERE ...")
int physicalDelete(...);
```
**问题：** 丢失了操作历史记录，无法进行数据分析和审计。

#### ✅ 方案3：恢复已删除记录（最终方案）
**核心思想：**
- 点赞/收藏时：先检查是否存在已逻辑删除的记录，如果存在则恢复（将deleted改为0），否则插入新记录
- 取消点赞/收藏时：执行逻辑删除（将deleted改为1）

**优点：**
1. ✅ 保留完整的操作历史
2. ✅ 避免主键ID不断增长
3. ✅ 数据库更加整洁（每个用户对每篇文章只有一条记录）
4. ✅ 支持数据分析（可以统计用户反复点赞/取消的行为）

## 实现细节

### 1. 数据库层（Mapper）

#### LikeRecordMapper.java
```java
/**
 * 查询点赞记录（包括已逻辑删除的）
 * 注意：不受 @TableLogic 影响，直接查询数据库
 */
@Select("SELECT * FROM like_record WHERE user_id = #{userId} AND target_id = #{targetId} AND type = #{type} LIMIT 1")
LikeRecord selectIncludeDeleted(@Param("userId") Long userId,
                                 @Param("targetId") Long targetId,
                                 @Param("type") Integer type);

/**
 * 恢复已逻辑删除的点赞记录
 * 同时更新 create_time 为当前时间
 */
@Update("UPDATE like_record SET deleted = 0, create_time = NOW() WHERE user_id = #{userId} AND target_id = #{targetId} AND type = #{type} AND deleted = 1")
int restoreDeleted(@Param("userId") Long userId,
                   @Param("targetId") Long targetId,
                   @Param("type") Integer type);
```

#### CollectMapper.java
```java
/**
 * 查询收藏记录（包括已逻辑删除的）
 */
@Select("SELECT * FROM collect WHERE user_id = #{userId} AND article_id = #{articleId} LIMIT 1")
Collect selectIncludeDeleted(@Param("userId") Long userId,
                              @Param("articleId") Long articleId);

/**
 * 恢复已逻辑删除的收藏记录
 */
@Update("UPDATE collect SET deleted = 0, create_time = NOW() WHERE user_id = #{userId} AND article_id = #{articleId} AND deleted = 1")
int restoreDeleted(@Param("userId") Long userId,
                   @Param("articleId") Long articleId);
```

### 2. 业务逻辑层（Service）

#### 点赞流程
```java
public void likeArticle(Long userId, Long articleId) {
    // 1. 验证文章是否存在
    Article article = articleMapper.selectById(articleId);
    if (article == null) {
        throw new CommonException("文章不存在");
    }

    // 2. 查询是否存在点赞记录（包括已逻辑删除的）
    LikeRecord existRecord = likeRecordMapper.selectIncludeDeleted(userId, articleId, 1);

    if (existRecord != null) {
        // 2.1 如果记录存在且未删除，说明已经点赞过
        if (existRecord.getDeleted() == 0) {
            throw new CommonException("您已经点赞过该文章");
        }

        // 2.2 如果记录存在但已删除，恢复该记录
        int restored = likeRecordMapper.restoreDeleted(userId, articleId, 1);
        if (restored <= 0) {
            throw new CommonException("点赞失败");
        }
        log.info("用户[{}]点赞文章[{}]成功（恢复已删除记录）", userId, articleId);
    } else {
        // 2.3 如果记录不存在，创建新记录
        LikeRecord likeRecord = LikeRecord.builder()
                .userId(userId)
                .targetId(articleId)
                .type(1)
                .build();

        int result = likeRecordMapper.insert(likeRecord);
        if (result <= 0) {
            throw new CommonException("点赞失败");
        }
        log.info("用户[{}]点赞文章[{}]成功（新增记录）", userId, articleId);
    }

    // 3. 增加文章点赞数
    articleMapper.incrementLikeCount(articleId);
}
```

#### 取消点赞流程
```java
public void unlikeArticle(Long userId, Long articleId) {
    // 1. 查询点赞记录（只查未删除的）
    LambdaQueryWrapper<LikeRecord> wrapper = new LambdaQueryWrapper<>();
    wrapper.eq(LikeRecord::getUserId, userId)
            .eq(LikeRecord::getTargetId, articleId)
            .eq(LikeRecord::getType, 1);

    LikeRecord likeRecord = likeRecordMapper.selectOne(wrapper);
    if (likeRecord == null) {
        throw new CommonException("您还未点赞该文章");
    }

    // 2. 逻辑删除点赞记录
    int result = likeRecordMapper.deleteById(likeRecord.getId());
    if (result <= 0) {
        throw new CommonException("取消点赞失败");
    }

    // 3. 减少文章点赞数
    articleMapper.decrementLikeCount(articleId);

    log.info("用户[{}]取消点赞文章[{}]成功", userId, articleId);
}
```

收藏功能的实现逻辑完全相同，只是操作的表不同。

### 3. 数据库索引优化

虽然采用了恢复记录的方案，但为了兼容性，仍然建议保持包含 `deleted` 字段的唯一索引：

```sql
-- like_record 表
ALTER TABLE `like_record` DROP INDEX `uk_user_target`;
ALTER TABLE `like_record` ADD UNIQUE INDEX `uk_user_target_deleted`(`user_id`, `target_id`, `type`, `deleted`);

-- collect 表
ALTER TABLE `collect` DROP INDEX `uk_user_article`;
ALTER TABLE `collect` ADD UNIQUE INDEX `uk_user_article_deleted`(`user_id`, `article_id`, `deleted`);

-- follow 表（预留）
ALTER TABLE `follow` DROP INDEX `uk_user_follow`;
ALTER TABLE `follow` ADD UNIQUE INDEX `uk_user_follow_deleted`(`user_id`, `follow_user_id`, `deleted`);
```

**原因：** 即使采用恢复记录的方案，如果因为并发或其他原因导致插入了多条记录，包含 `deleted` 的唯一索引仍然可以保证数据一致性。

## 优化效果对比

### 优化前
```
用户操作流程：点赞 → 取消点赞 → 再次点赞
数据库记录：
  id=1, user_id=1, article_id=100, deleted=1  (逻辑删除)
  id=2, user_id=1, article_id=100, deleted=0  (新插入，报错！唯一索引冲突)
```

### 优化后
```
用户操作流程：点赞 → 取消点赞 → 再次点赞
数据库记录：
  id=1, user_id=1, article_id=100, deleted=0  (恢复记录，create_time更新为当前时间)
```

## 测试场景

### 场景1：首次点赞
1. 用户点赞文章
2. 数据库插入新记录（deleted=0）
3. 文章点赞数+1

### 场景2：取消点赞
1. 用户取消点赞
2. 数据库记录逻辑删除（deleted=1）
3. 文章点赞数-1

### 场景3：再次点赞（核心场景）
1. 用户再次点赞文章
2. 系统检测到存在已删除记录
3. 恢复该记录（deleted=0, create_time=NOW()）
4. 文章点赞数+1

### 场景4：并发点赞（压力测试）
1. 用户快速连续点击点赞按钮
2. 第一个请求：插入新记录
3. 第二个请求：检测到已存在记录，提示"您已经点赞过该文章"

## 注意事项

1. **create_time 更新**
   - 恢复记录时会更新 `create_time` 为当前时间
   - 这样可以准确记录用户最后一次点赞的时间
   - 如果需要保留首次点赞时间，可以另外添加 `first_like_time` 字段

2. **并发控制**
   - 使用事务 `@Transactional` 保证原子性
   - 数据库唯一索引作为最后一道防线
   - 如果需要更严格的并发控制，可以考虑使用分布式锁

3. **性能优化**
   - `selectIncludeDeleted()` 使用 `LIMIT 1` 提高查询效率
   - 建议在 `(user_id, target_id, type, deleted)` 上创建复合索引
   - 对于高频操作，可以考虑使用 Redis 缓存点赞状态

4. **数据清理**
   - 虽然采用了恢复记录的方案，但仍会有部分用户只点赞一次后就取消，这些记录会一直保留
   - 可以定期清理长期处于 `deleted=1` 状态的记录（如超过1年未恢复的记录）
   - 清理时需要注意保留有价值的历史数据用于数据分析

## 扩展应用

这种"恢复已删除记录"的模式也适用于其他类似场景：
- 关注/取消关注用户
- 添加/移除购物车商品
- 订阅/取消订阅话题
- 加入/退出群组

## 总结

通过"恢复已删除记录"的方案，我们既保留了逻辑删除的优点（数据可追溯），又解决了唯一索引冲突的问题，同时避免了数据库记录的无限增长。这是一个在**数据完整性、性能和存储空间之间取得平衡的优雅方案**。
